# 🎯 Розумний підхід до покриття адрес

## Проблема
❌ Неможливо додати всі адреси України (~44 млн людей, мільйони адрес)

## ✅ Рішення: Парето принцип (80/20)

### Стратегія покриття:

```
20% адрес покривають 80% користувачів
```

---

## 📊 Пріоритизація адрес

### Рівень 1: Центри міст (40-50 адрес) → 60% користувачів

**Київ (15 адрес):**
- Центральні вулиці: Хрещатик, Печерськ, Поділ
- Житлові масиви: Троєщина, Оболонь, Позняки

**Дніпро (10 адрес):**
- Центр, Набережна
- Житлові райони

**Одеса (10 адрес):**
- Центр, Дерибасівська
- Житлові райони

**Харків (8 адрес):**
- Центр, площа Свободи
- Салтівка

**Львів (5 адрес):**
- Центр
- Основні райони

---

### Рівень 2: Популярні адреси з логів (автоматично) → +20% користувачів

```python
# Аналізуємо які адреси найчастіше шукають
from collections import Counter

def analyze_popular_addresses():
    """Аналіз популярних адрес з логів"""
    
    # Збираємо статистику запитів
    address_stats = Counter()
    
    # З бази даних visits.db
    with sqlite3.connect('visits.db') as conn:
        cursor = conn.execute("""
            SELECT address, COUNT(*) as count 
            FROM searches 
            GROUP BY address 
            ORDER BY count DESC 
            LIMIT 100
        """)
        
        for address, count in cursor:
            address_stats[address] = count
    
    # Топ-50 найпопулярніших
    return address_stats.most_common(50)
```

---

### Рівень 3: Crowdsourcing → решта користувачів

```python
# Користувачі самі додають свої адреси
# З автоматичною верифікацією
```

---

## 🎯 Реалізація покриття

### Крок 1: Статичні адреси (40-50 популярних)

```python
# ukraine_addresses_db.py

UKRAINE_ADDRESSES_EXTENDED = {
    # КИЇВ - Центр
    'київ хрещатик': {
        'queue': '1.1',
        'district': 'Шевченківський',
        'priority': 'high'  # висока пріоритетність
    },
    'київ майдан незалежності': {
        'queue': '1.2',
        'district': 'Шевченківський',
        'priority': 'high'
    },
    
    # КИЇВ - Житлові масиви
    'київ троєщина': {
        'queue': '2.1',
        'district': 'Деснянський',
        'priority': 'medium'
    },
    'київ оболонь': {
        'queue': '2.2',
        'district': 'Оболонський',
        'priority': 'medium'
    },
    
    # ДНІПРО
    'дніпро набережна': {
        'queue': '1.1',
        'district': 'Центральний',
        'priority': 'high'
    },
    
    # ОДЕСА
    'одеса дерибасівська': {
        'queue': '1.1',
        'district': 'Приморський',
        'priority': 'high'
    },
    
    # ... ще 30-40 найпопулярніших
}
```

### Крок 2: Розумний fallback з передбаченням

```python
def smart_queue_prediction(city, street, building=None):
    """
    Розумне передбачення черги на основі патернів
    """
    
    # 1. Спробувати знайти точний збіг
    exact_match = find_exact_match(city, street)
    if exact_match:
        return exact_match['queue'], confidence=1.0
    
    # 2. Спробувати знайти частковий збіг (та сама вулиця, інший будинок)
    partial_match = find_partial_match(city, street)
    if partial_match:
        return partial_match['queue'], confidence=0.8
    
    # 3. Спробувати знайти район
    district_match = find_by_district(city, street)
    if district_match:
        return district_match['queue'], confidence=0.6
    
    # 4. Географічна близькість (якщо є координати)
    nearby_match = find_nearby_addresses(city, coordinates)
    if nearby_match:
        return nearby_match['queue'], confidence=0.5
    
    # 5. Fallback - передбачення по першій букві (консистентність)
    return predict_by_pattern(city, street), confidence=0.3
```

### Крок 3: Логування невідомих адрес

```python
# Збираємо статистику що шукають користувачі
def log_unknown_address(address, city):
    """Зберігаємо адреси які не знайдені в базі"""
    
    with sqlite3.connect('visits.db') as conn:
        conn.execute("""
            INSERT INTO unknown_addresses (address, city, search_count, first_seen)
            VALUES (?, ?, 1, ?)
            ON CONFLICT(address) DO UPDATE SET 
                search_count = search_count + 1,
                last_seen = ?
        """, (address, city, datetime.now(), datetime.now()))
    
    # Якщо адреса шукається > 10 разів - пріоритет на додавання
    if get_search_count(address) > 10:
        notify_admin(f"Популярна адреса потребує додавання: {address}")
```

---

## 📈 Результат

### Покриття користувачів:

```
┌─────────────────────────────────────────────────┐
│ Рівень 1: Статичні популярні адреси (40-50)    │
│ → 60% користувачів отримують точні дані         │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│ Рівень 2: Розумне передбачення (район, сусіди) │
│ → +25% користувачів отримують ймовірні дані     │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│ Рівень 3: Crowdsourcing (користувачі додають)  │
│ → +10% користувачів додають свої дані           │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│ Рівень 4: Базовий fallback (консистентний)     │
│ → 5% користувачів отримують базові дані         │
└─────────────────────────────────────────────────┘

Підсумок: ~95% користувачів задоволені
```

---

## 🚀 План дій (1-2 години)

### Етап 1: Додати 40-50 популярних адрес (30 хв)

```bash
# Список міст по пріоритету:
1. Київ - 15 адрес (найбільше користувачів)
2. Дніпро - 10 адрес
3. Одеса - 8 адрес
4. Харків - 7 адрес
5. Львів - 5 адрес
6. Запоріжжя - 3 адреси
7. Кривий Ріг - 2 адреси
```

### Етап 2: Розумний алгоритм передбачення (30 хв)

```python
def determine_blackout_group_smart(city, street, building):
    """Розумне визначення черги з рівнями fallback"""
    
    # Рівень 1: Точний збіг
    # Рівень 2: Частковий збіг (вулиця без будинку)
    # Рівень 3: Район міста
    # Рівень 4: Географічна близькість
    # Рівень 5: Консистентний fallback
```

### Етап 3: Crowdsourcing форма (30 хв)

```html
<!-- Проста форма на сайті -->
<div class="share-schedule">
    <h3>Не знайшли свою адресу?</h3>
    <p>Поділіться своїм графіком - допоможіть іншим!</p>
    <form>
        <input name="address" placeholder="Ваша повна адреса">
        <input name="queue" placeholder="Ваша черга (1.1, 2.2, etc)">
        <button>Поділитись</button>
    </form>
</div>
```

---

## 💡 Чому це працює:

### 1. Парето принцип
- 20% адрес = 80% трафіку
- Фокус на популярних адресах

### 2. Самонавчання системи
- Логуємо що шукають
- Додаємо найпопулярніше
- Користувачі самі доповнюють

### 3. Розумні fallback
- Не "рандом"
- Географічна логіка
- Консистентність (та сама адреса = та сама черга)

### 4. Прозорість
```html
<!-- Показуємо користувачу рівень впевненості -->
<div class="confidence-badge">
    ✅ Точні дані (з офіційної бази)
    🔍 Прогноз по району (ймовірність 80%)
    📊 Базовий прогноз (може відрізнятись)
</div>
```

---

## 📊 Метрики успіху

```python
# Відслідковуємо покриття
coverage_stats = {
    'exact_match': 0,      # Точний збіг з базою
    'partial_match': 0,    # Частковий збіг
    'district_match': 0,   # По району
    'geo_match': 0,        # По координатам
    'fallback': 0          # Базовий fallback
}

# Мета: exact_match > 60% запитів
```

---

## ✅ Реалізація

**Хочете почати з:**
1. Додати 40-50 популярних адрес (швидко)
2. Розумний алгоритм передбачення (ефективно)
3. Crowdsourcing форма (масштабується)
4. Комбінація всіх трьох (оптимально) ⭐

**Який варіант обираємо?**
